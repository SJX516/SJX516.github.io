<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[OkHttp源码分析]]></title>
      <url>%2F2016%2F12%2F04%2FOkHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[异步请求流程 从这样一句话开始发出一个异步的请求 okHttpClient.newCall(request).enqueue(callback); 实际上调用的是 RealCall 的 enqueue 方法，将回调包装成一个 AsyncCall(NamedRunnabled的子类) 传递给了 Client 的 Dispatcher 12345678910111213//@see OkHttpClient@Override public Call newCall(Request request) &#123; return new RealCall(this, request);&#125;//@see RealCall@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; client.dispatcher().enqueue(new AsyncCall(responseCallback));&#125; 每当 Dispatcher 收到一个新的 AsyncCall 如果有空闲的线程就去将其放入执行队列，并执行它 没有的话，就放入等待队列 123456789//@see Dispatchersynchronized void enqueue(AsyncCall call) &#123; if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; runningAsyncCalls.add(call); executorService().execute(call); &#125; else &#123; readyAsyncCalls.add(call); &#125;&#125; AsyncCall 的执行过程通过 getResponseWithInterceptorChain() 来链式调用client.interceptors()，从上到下层层包装了各种缓存、重试等机制，并添加部分默认的Headers参数等，最后调用到CallServerInterceptor.intercept(Chain chain)方法和服务器建立 Socket 连接取得 Response，然后再把 Response 沿着来时的顺序由下往上层层返回，并进行相应的处理，最后返回到 AsyncCall 的 execute 方法中。 然后相应的调用成功或失败的回调（还是在执行线程中，不会切换到主线程） 123456789101112131415161718192021222324252627282930313233343536373839404142//@see RealCall.AsyncCall @Override protected void execute() &#123; boolean signalledCallback = false; try &#123; Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;)); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e); &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125;private Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!retryAndFollowUpInterceptor.isForWebSocket()) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor( retryAndFollowUpInterceptor.isForWebSocket())); Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest);&#125; 最后在client.dispatcher().finished()方法中会 将该 AsyncCall 从执行队列中移除 调用Dispatcher.promoteCalls()方法来将等待队列中的 AsyncCall 放入执行队列中并执行 1234567891011121314151617//@see Dispatcherprivate void promoteCalls() &#123; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity. if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote. for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall call = i.next(); if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; i.remove(); runningAsyncCalls.add(call); executorService().execute(call); &#125; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity. &#125;&#125; 同步请求流程这个会把 realCall 放到 dispatcher 的 runningSyncCalls 中，用于对请求的统一管理 并直接在当前线程调用getResponseWithInterceptorChain()获得 Response 123456789101112131415//@see RealCall@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; try &#123; client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(&quot;Canceled&quot;); return result; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iTerm2配色设置]]></title>
      <url>%2F2016%2F11%2F30%2FiTerm2%E9%85%8D%E8%89%B2%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[iTerm2 颜色生效配置bash设置在导入并应用完颜色方案之后，通过命令vim ~/.bash_profile 或open ~/.bash_profile编辑文件，添加以下内容，之后source ~/.bash_profile来应用文件修改。 1234CLICOLOR=1LSCOLORS=gxfxcxdxbxegedabagacadexport PS1=&apos;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;36m\]\w\[\033[00m\]\$ &apos;export TERM=xterm-color 这样之后ls还是不能显示颜色，需要指定ls -G才能显示颜色，这里我们可以为它配置别名，通过命令vim ~/.bashrc或open ~/.bashrc编辑文件，添加以下内容，之后source ~/.bashrc来应用修改。 12alias ll=&apos;ls -lG&apos;alias ls=&apos;ls -G&apos; 保存后还需对 .bash_profile 进行一些设置。打开 .bash_profile 文件，添加以下内容。 123if [ -f ~/.bashrc ]; then source ~/.bashrcfi 原因是对于Mac系统，每次开机运行时是执行 .bash_profile 文件，而不会执行 .bashrc 文件，所以在 .bash_profile 文件中添加上述内容，让Mac在执行 .bash_profile 时让 .bashrc 文件生效。 zsh设置或者直接将shell改为zsh，便可以直接使用对应的配色了 克隆这个项目到本地(前提是你得有装git) git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 创建一个zsh的配置文件注意:如果你已经有一个~/.zshrc文件的话，建议你先做备份。使用以下命令 cp ~/.zshrc ~/.zshrc.orig 然后开始创建zsh的配置文件 cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 设置zsh为你的默认的shell chsh -s /bin/zsh 重启并开始使用你的zsh (打开一个新的终端窗口便可…) 至此，大功告成。 通过vim ~/.zshrc 来编辑你的配置文件，例如把(~/.bash_prorile或者~/.profile等)给拷贝到zsh的配置文件~/.zshrc里，因为zsh兼容bash，所以你大可放心把bash的配置粘贴到~/.zshrc底部便可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AS中的Gradle文件配置]]></title>
      <url>%2F2016%2F11%2F24%2FAS%E4%B8%AD%E7%9A%84Gradle%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[AS中的Gradle文件配置参考链接 总览Android app module 的构建过程 自定义构建配置Build Types Build types 通常用于定义开发周期中的不同阶段，例如在 debug 阶段开启debug选项， release 阶段开启代码压缩、代码混淆并使用正式的key对apk进行签名。 Product Flavors Product flavors 代表app发行的不同版本，例如免费版和付费版，可以让不同的 Product flavors 使用不同的代码和资源文件，或者只是定义不同的渠道包。 defaultConfig 属于 Product Flavors，相当于默认的基本配置 Build Variants build variant = product flavor + build type, Gradle会把 product flavor 和 build type 的配置组合在一起，形成一个 build variant 的配置，由系统自动生成。 Manifest Entries build variant 的部分配置信息会直接覆盖到 manifest 文件上去，例如 applicationId、versionName、target SDK version 等。 也可以通过 manifestPlaceholders 来配置跟不同的 build variant 相关的变量 123defaultConfig &#123; manifestPlaceholders = [NAME:&quot;value&quot;]&#125; 然后这样在 manifest 中使用变量 123&lt;meta-data android:name=&quot;TYPE_VALUE&quot; android:value=&quot;$&#123;NAME&#125;&quot; /&gt; Dependencies 构建系统通过 dependencies 来管理本地依赖文件和远程仓库依赖。 Signing 可以在不同的 buildTypes 中配置 signingConfig 来选择签名配置，构建系统会使用默认的key去打包 debuggable 为 true 的版本，release版本的 signingConfig 需要自己配置。 一个 applicationId 唯一确定一个apk 相同的 applicationId，打包的key不同的话，以最先发布的apk的key为准 ProGuard 不同的 build variants 可以采用不同的 ProGuard rules file，当配置了多个时，会把它们合并到一起。 APK Splits 可以使用指定的代码和资源文件来打包对应不同分辨率的apk。（当你的apk为了支持不同分辨率导致体积在100M以上时，才推荐这么做） 源代码设置不同目录下的代码和资源文件会按照是否需要以及相应的优先级合并到一起，组合成最后的 buildVariant 所对应的代码 src/main/ This source set includes code and resources common to all build variants. src/buildType/ only for a specific build type. src/productFlavor/ only for a specific product flavor. src/productFlavorBuildType/ only for a specific build variant. 当不同目录的代码有冲突时，会按照下面的优先级来选择 build variant &gt; build type &gt; product flavor &gt; main source set &gt; library dependencies]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RxJava基础使用及原理分析]]></title>
      <url>%2F2016%2F11%2F21%2FRxJava%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[RxJava基础使用及原理分析基本使用12345678910111213141516171819202122Observable.create(new OnSubscribe&lt;Drawable&gt;() &#123; @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123; Drawable drawable = getTheme().getDrawable(drawableRes)); subscriber.onNext(drawable); subscriber.onCompleted(); &#125;&#125;).subscribe(new Observer&lt;Drawable&gt;() &#123; @Override public void onNext(Drawable drawable) &#123; imageView.setImageDrawable(drawable); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(activity, &quot;Error!&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;); 变换的原理：lift()先是一个Operator的概念： 123456789101112// 注意：这不是 lift() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。public &lt;R&gt; Observable&lt;R&gt; lift(Operator&lt;? extends R, ? super T&gt; operator) &#123; return Observable.create(new OnSubscribe&lt;R&gt;() &#123; @Override public void call(Subscriber subscriber) &#123; Subscriber newSubscriber = operator.call(subscriber); newSubscriber.onStart(); onSubscribe.call(newSubscriber); &#125; &#125;);&#125; 当含有 lift() 时： lift() 创建了一个 Observable 后，加上之前的原始 Observable，已经有两个 Observable 了； 而同样地，新 Observable 里的新 OnSubscribe 加上之前的原始 Observable 中的原始 OnSubscribe，也就有了两个 OnSubscribe； 当用户调用经过 lift() 后的 Observable 的 subscribe() 的时候，使用的是 lift() 所返回的新的 Observable ，于是它所触发的 onSubscribe.call(subscriber)，也是用的新 Observable 中的新 OnSubscribe，即在 lift() 中生成的那个 OnSubscribe； 而这个新 OnSubscribe 的 call() 方法中的 onSubscribe ，就是指的原始 Observable 中的原始 OnSubscribe ，在这个 call() 方法里，新 OnSubscribe 利用 operator.call(subscriber) 生成了一个新的 Subscriber（Operator 就是在这里，通过自己的 call() 方法将新 Subscriber 和原始 Subscriber 进行关联，并插入自己的『变换』代码以实现变换），然后利用这个新 Subscriber 向原始 Observable 进行订阅。 这样就实现了 lift() 过程，有点像一种代理机制，通过事件拦截和处理实现事件序列的变换。 Scheduler 的原理 subscribeOn：在OnSubscriberB的call方法切换线程并构建newSubscriber 123456789101112131415161718192021222324252627282930// subscriberOn的核心代码public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; return Observable.create(new Observable.OnSubscribe&lt;T&gt;() &#123; @Override public void call(Subscriber&lt;? super T&gt; subscriber) &#123; final Scheduler.Worker inner = scheduler.createWorker(); inner.schedule(new Action0() &#123; @Override public void call() &#123; Subscriber&lt;T&gt; newSubscriber = new Subscriber&lt;T&gt;(subscriber) &#123; @Override public void onNext(T t) &#123; subscriber.onNext(t); &#125; @Override public void onError(Throwable e) &#123; subscriber.onError(e); &#125; @Override public void onCompleted() &#123; subscriber.onCompleted(); &#125; &#125;; newSubscriber.onStart(); onSubscribe.call(newSubscriber); &#125; &#125;); &#125; &#125;);&#125; observeOn：比较复杂，不贴代码了，过程就是一个lift操作，提供了一个中间的ObserveOnSubscriber，每当ObserveOnSubscriber收到一个onNext或其他消息时，就调用Worker在相应的线程中处理这条消息 当多个 subscribeOn() 和 observeOn() 混合使用时 图中共有 5 处含有对事件的操作。由图中可以看出，①和②两处受第一个 subscribeOn() 影响，运行在红色线程；③和④处受第一个 observeOn() 的影响，运行在绿色线程；⑤处受第二个 onserveOn() 影响，运行在紫色线程；而第二个 subscribeOn() ，由于在通知过程中线程就被第一个 subscribeOn() 截断，因此对整个流程并没有任何影响。这里也就回答了前面的问题：当使用了多个 subscribeOn() 的时候，只有第一个 subscribeOn() 起作用。 参考链接给 Android 开发者的 RxJava 详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Fresco介绍]]></title>
      <url>%2F2016%2F11%2F04%2FFresco%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[Fresco介绍###关于 Fresco Fresco中文文档 详细使用 ImagePipe 指南 Fresco 是一个强大的图片加载组件。 Fresco 中设计有一个叫做 image pipeline 的模块。它负责从网络，从本地文件系统，本地资源加载图片。为了最大限度节省空间和CPU时间，它含有3级缓存设计（2级内存，1级文件）。 Fresco 中设计有一个叫做 Drawees 模块，方便地显示loading图，当图片不再显示在屏幕上时，及时地释放内存和空间占用。 Fresco 支持 Android2.3(API level 9) 及其以上系统。 基本使用 通过 ImagePipelineConfig 设置图片的获取和管理的配置，并在初始化Fresco的时候注入 123456789101112131415ImagePipelineConfig config = ImagePipelineConfig.newBuilder() .setBitmapMemoryCacheParamsSupplier(bitmapCacheParamsSupplier) .setCacheKeyFactory(cacheKeyFactory) .setEncodedMemoryCacheParamsSupplier(encodedCacheParamsSupplier) .setExecutorSupplier(executorSupplier) .setImageCacheStatsTracker(imageCacheStatsTracker) .setMainDiskCacheConfig(mainDiskCacheConfig) .setMemoryTrimmableRegistry(memoryTrimmableRegistry) .setNetworkFetchProducer(networkFetchProducer) .setPoolFactory(poolFactory) .setProgressiveJpegConfig(progressiveJpegConfig) .setRequestListeners(requestListeners) .setSmallImageDiskCacheConfig(smallImageDiskCacheConfig) .build();Fresco.initialize(context, config); DraweeHierarchy 用于组织和维护最终绘制和呈现的 Drawable 对象，包括占位图，错误图，圆角等属性（这些属性部分可以在 XML 中设定） 123456GenericDraweeHierarchy hierarchy = builder .setFadeDuration(300) .setPlaceholderImage(new MyCustomDrawable()) .setBackgrounds(backgroundList) .setOverlays(overlaysList) .build(); ImageRequest 用于控制真正显示的图片的请求，包括多图请求、图片复用、缩放旋转图片、对获取到的图片进行修改 等 123456789ImageRequest request = ImageRequestBuilder .newBuilderWithSource(uri) .setImageDecodeOptions(decodeOptions) .setAutoRotateEnabled(true) .setLocalThumbnailPreviewsEnabled(true) .setLowestPermittedRequestLevel(RequestLevel.FULL_FETCH) .setProgressiveRenderingEnabled(false) .setResizeOptions(new ResizeOptions(width, height)) .build(); DraweeController 负责和 image loader 交互，用于实现对所要显示的图片做更多的控制，例如重试点击监听、加载进度监听、控制动画播放等 123456DraweeController controller = Fresco.newDraweeControllerBuilder() .setUri(uri) .setTapToRetryEnabled(true) .setOldController(mSimpleDraweeView.getController()) .setControllerListener(listener) .build(); 通过向 DraweeView 上注入 Hierarchy 和 Controller 来显示图片 12mSimpleDraweeView.setHierarchy(hierarchy);mSimpleDraweeView.setController(controller);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OkHttp header、post参数不支持中文的解决办法]]></title>
      <url>%2F2016%2F10%2F19%2FOkHttp%20header%E3%80%81post%E5%8F%82%E6%95%B0%E4%B8%8D%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
      <content type="text"><![CDATA[现象项目在接入Okhttp请求框架的时候，发现当header或post参数中包含有中文的时候，都会报一个 Unexpected char xx at xx in xx value: xxx 这种格式的错误，下面把原因和解决办法分享给大家 原因查看源码可以发现，不论你从什么入口设置header 或 post参数，Okhttp都会对其进行这样一段代码的检查 private void checkNameAndValue(String name, String value) { if (name == null) throw new NullPointerException(&quot;name == null&quot;); if (name.isEmpty()) throw new IllegalArgumentException(&quot;name is empty&quot;); for (int i = 0, length = name.length(); i &lt; length; i++) { char c = name.charAt(i); if (c &lt;= &apos;\u001f&apos; || c &gt;= &apos;\u007f&apos;) { throw new IllegalArgumentException(Util.format( &quot;Unexpected char %#04x at %d in header name: %s&quot;, (int) c, i, name)); } } if (value == null) throw new NullPointerException(&quot;value == null&quot;); for (int i = 0, length = value.length(); i &lt; length; i++) { char c = value.charAt(i); if (c &lt;= &apos;\u001f&apos; || c &gt;= &apos;\u007f&apos;) { throw new IllegalArgumentException(Util.format( &quot;Unexpected char %#04x at %d in %s value: %s&quot;, (int) c, i, name, value)); } } } 而这也就使得当参数中含有中文时就会报错 解决办法header参数把使用 requestBuilder.header(name , value)的地方 替换成requestBuilder.header(name , getValueEncoded(value) ) 方法代码如下： //由于okhttp header 中的 value 不支持 null, \n 和 中文这样的特殊字符,所以这里 //会首先替换 \n ,然后使用 okhttp 的校验方式,校验不通过的话,就返回 encode 后的字符串 private static String getValueEncoded(String value) { if (value == null) return &quot;null&quot;; String newValue = value.replace(&quot;\n&quot;, &quot;&quot;); for (int i = 0, length = newValue.length(); i &lt; length; i++) { char c = newValue.charAt(i); if (c &lt;= &apos;\u001f&apos; || c &gt;= &apos;\u007f&apos;) { return URLEncoder.encode(newValue, &quot;UTF-8&quot;); } } return newValue; } post参数post参数可以通过将键值对转换为byte数组的形式来避免OKhttp的字符检查 requestBuilder.post(RequestBody.create(MediaType.parse(&quot;application/x-www-form-urlencoded; charset=utf-8&quot;), getRequestData(postParams).toString().getBytes(“UTF-8”))); private static StringBuffer getRequestData(Map&lt;String, String&gt; params) { StringBuffer stringBuffer = new StringBuffer(); try { for (Map.Entry&lt;String, String&gt; entry : params.entrySet()) { stringBuffer.append(entry.getKey()).append(&quot;=&quot;).append(entry.getValue()).append(&quot;&amp;&quot;); } stringBuffer.deleteCharAt(stringBuffer.length() - 1); //删除最后的一个&quot;&amp;&quot; } catch (Exception e) { e.printStackTrace(); } return stringBuffer; } 另外，这里比较重要的还有这句话： MediaType.parse(&quot;application/x-www-form-urlencoded; charset=utf-8&quot; 此处如果没有charset=utf-8的话，服务端获取中文post参数可能会出现乱码]]></content>
    </entry>

    
  
  
</search>
