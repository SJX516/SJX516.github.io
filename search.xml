<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[AS中的Gradle文件配置]]></title>
      <url>%2F2016%2F11%2F24%2FAS%E4%B8%AD%E7%9A%84Gradle%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[AS中的Gradle文件配置参考链接 总览Android app module 的构建过程 自定义构建配置Build Types Build types 通常用于定义开发周期中的不同阶段，例如在 debug 阶段开启debug选项， release 阶段开启代码压缩、代码混淆并使用正式的key对apk进行签名。 Product Flavors Product flavors 代表app发行的不同版本，例如免费版和付费版，可以让不同的 Product flavors 使用不同的代码和资源文件，或者只是定义不同的渠道包。 defaultConfig 属于 Product Flavors，相当于默认的基本配置 Build Variants build variant = product flavor + build type, Gradle会把 product flavor 和 build type 的配置组合在一起，形成一个 build variant 的配置，由系统自动生成。 Manifest Entries build variant 的部分配置信息会直接覆盖到 manifest 文件上去，例如 applicationId、versionName、target SDK version 等。 也可以通过 manifestPlaceholders 来配置跟不同的 build variant 相关的变量 123defaultConfig &#123; manifestPlaceholders = [NAME:&quot;value&quot;]&#125; 然后这样在 manifest 中使用变量 123&lt;meta-data android:name=&quot;TYPE_VALUE&quot; android:value=&quot;$&#123;NAME&#125;&quot; /&gt; Dependencies 构建系统通过 dependencies 来管理本地依赖文件和远程仓库依赖。 Signing 可以在不同的 buildTypes 中配置 signingConfig 来选择签名配置，构建系统会使用默认的key去打包 debuggable 为 true 的版本，release版本的 signingConfig 需要自己配置。 一个 applicationId 唯一确定一个apk 相同的 applicationId，打包的key不同的话，以最先发布的apk的key为准 ProGuard 不同的 build variants 可以采用不同的 ProGuard rules file，当配置了多个时，会把它们合并到一起。 APK Splits 可以使用指定的代码和资源文件来打包对应不同分辨率的apk。（当你的apk为了支持不同分辨率导致体积在100M以上时，才推荐这么做） 源代码设置不同目录下的代码和资源文件会按照是否需要以及相应的优先级合并到一起，组合成最后的 buildVariant 所对应的代码 src/main/ This source set includes code and resources common to all build variants. src/buildType/ only for a specific build type. src/productFlavor/ only for a specific product flavor. src/productFlavorBuildType/ only for a specific build variant. 当不同目录的代码有冲突时，会按照下面的优先级来选择 build variant &gt; build type &gt; product flavor &gt; main source set &gt; library dependencies]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Okhttp header、post参数不支持中文的解决办法]]></title>
      <url>%2F2016%2F10%2F19%2FOkhttp%20header%E3%80%81post%E5%8F%82%E6%95%B0%E4%B8%8D%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
      <content type="text"><![CDATA[现象项目在接入Okhttp请求框架的时候，发现当header或post参数中包含有中文的时候，都会报一个 Unexpected char xx at xx in xx value: xxx 这种格式的错误，下面把原因和解决办法分享给大家 原因查看源码可以发现，不论你从什么入口设置header 或 post参数，Okhttp都会对其进行这样一段代码的检查 private void checkNameAndValue(String name, String value) { if (name == null) throw new NullPointerException(&quot;name == null&quot;); if (name.isEmpty()) throw new IllegalArgumentException(&quot;name is empty&quot;); for (int i = 0, length = name.length(); i &lt; length; i++) { char c = name.charAt(i); if (c &lt;= &apos;\u001f&apos; || c &gt;= &apos;\u007f&apos;) { throw new IllegalArgumentException(Util.format( &quot;Unexpected char %#04x at %d in header name: %s&quot;, (int) c, i, name)); } } if (value == null) throw new NullPointerException(&quot;value == null&quot;); for (int i = 0, length = value.length(); i &lt; length; i++) { char c = value.charAt(i); if (c &lt;= &apos;\u001f&apos; || c &gt;= &apos;\u007f&apos;) { throw new IllegalArgumentException(Util.format( &quot;Unexpected char %#04x at %d in %s value: %s&quot;, (int) c, i, name, value)); } } } 而这也就使得当参数中含有中文时就会报错 解决办法header参数把使用 requestBuilder.header(name , value)的地方 替换成requestBuilder.header(name , getValueEncoded(value) ) 方法代码如下： //由于okhttp header 中的 value 不支持 null, \n 和 中文这样的特殊字符,所以这里 //会首先替换 \n ,然后使用 okhttp 的校验方式,校验不通过的话,就返回 encode 后的字符串 private static String getValueEncoded(String value) { if (value == null) return &quot;null&quot;; String newValue = value.replace(&quot;\n&quot;, &quot;&quot;); for (int i = 0, length = newValue.length(); i &lt; length; i++) { char c = newValue.charAt(i); if (c &lt;= &apos;\u001f&apos; || c &gt;= &apos;\u007f&apos;) { return URLEncoder.encode(newValue, &quot;UTF-8&quot;); } } return newValue; } post参数post参数可以通过将键值对转换为byte数组的形式来避免OKhttp的字符检查 requestBuilder.post(RequestBody.create(MediaType.parse(&quot;application/x-www-form-urlencoded; charset=utf-8&quot;), getRequestData(postParams).toString().getBytes(“UTF-8”))); private static StringBuffer getRequestData(Map&lt;String, String&gt; params) { StringBuffer stringBuffer = new StringBuffer(); try { for (Map.Entry&lt;String, String&gt; entry : params.entrySet()) { stringBuffer.append(entry.getKey()).append(&quot;=&quot;).append(entry.getValue()).append(&quot;&amp;&quot;); } stringBuffer.deleteCharAt(stringBuffer.length() - 1); //删除最后的一个&quot;&amp;&quot; } catch (Exception e) { e.printStackTrace(); } return stringBuffer; } 另外，这里比较重要的还有这句话： MediaType.parse(&quot;application/x-www-form-urlencoded; charset=utf-8&quot; 此处如果没有charset=utf-8的话，服务端获取中文post参数可能会出现乱码]]></content>
    </entry>

    
  
  
</search>
