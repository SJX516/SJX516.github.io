<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[iTerm2配色设置]]></title>
      <url>%2F2016%2F11%2F30%2FiTerm2%E9%85%8D%E8%89%B2%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[iTerm2 颜色生效配置bash设置在导入并应用完颜色方案之后，通过命令vim ~/.bash_profile 或open ~/.bash_profile编辑文件，添加以下内容，之后source ~/.bash_profile来应用文件修改。 1234CLICOLOR=1LSCOLORS=gxfxcxdxbxegedabagacadexport PS1=&apos;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;36m\]\w\[\033[00m\]\$ &apos;export TERM=xterm-color 这样之后ls还是不能显示颜色，需要指定ls -G才能显示颜色，这里我们可以为它配置别名，通过命令vim ~/.bashrc或open ~/.bashrc编辑文件，添加以下内容，之后source ~/.bashrc来应用修改。 12alias ll=&apos;ls -lG&apos;alias ls=&apos;ls -G&apos; 保存后还需对 .bash_profile 进行一些设置。打开 .bash_profile 文件，添加以下内容。 123if [ -f ~/.bashrc ]; then source ~/.bashrcfi 原因是对于Mac系统，每次开机运行时是执行 .bash_profile 文件，而不会执行 .bashrc 文件，所以在 .bash_profile 文件中添加上述内容，让Mac在执行 .bash_profile 时让 .bashrc 文件生效。 zsh设置或者直接将shell改为zsh，便可以直接使用对应的配色了 克隆这个项目到本地(前提是你得有装git) git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 创建一个zsh的配置文件注意:如果你已经有一个~/.zshrc文件的话，建议你先做备份。使用以下命令 cp ~/.zshrc ~/.zshrc.orig 然后开始创建zsh的配置文件 cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 设置zsh为你的默认的shell chsh -s /bin/zsh 重启并开始使用你的zsh (打开一个新的终端窗口便可…) 至此，大功告成。 通过vim ~/.zshrc 来编辑你的配置文件，例如把(~/.bash_prorile或者~/.profile等)给拷贝到zsh的配置文件~/.zshrc里，因为zsh兼容bash，所以你大可放心把bash的配置粘贴到~/.zshrc底部便可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AS中的Gradle文件配置]]></title>
      <url>%2F2016%2F11%2F24%2FAS%E4%B8%AD%E7%9A%84Gradle%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[AS中的Gradle文件配置参考链接 总览Android app module 的构建过程 自定义构建配置Build Types Build types 通常用于定义开发周期中的不同阶段，例如在 debug 阶段开启debug选项， release 阶段开启代码压缩、代码混淆并使用正式的key对apk进行签名。 Product Flavors Product flavors 代表app发行的不同版本，例如免费版和付费版，可以让不同的 Product flavors 使用不同的代码和资源文件，或者只是定义不同的渠道包。 defaultConfig 属于 Product Flavors，相当于默认的基本配置 Build Variants build variant = product flavor + build type, Gradle会把 product flavor 和 build type 的配置组合在一起，形成一个 build variant 的配置，由系统自动生成。 Manifest Entries build variant 的部分配置信息会直接覆盖到 manifest 文件上去，例如 applicationId、versionName、target SDK version 等。 也可以通过 manifestPlaceholders 来配置跟不同的 build variant 相关的变量 123defaultConfig &#123; manifestPlaceholders = [NAME:&quot;value&quot;]&#125; 然后这样在 manifest 中使用变量 123&lt;meta-data android:name=&quot;TYPE_VALUE&quot; android:value=&quot;$&#123;NAME&#125;&quot; /&gt; Dependencies 构建系统通过 dependencies 来管理本地依赖文件和远程仓库依赖。 Signing 可以在不同的 buildTypes 中配置 signingConfig 来选择签名配置，构建系统会使用默认的key去打包 debuggable 为 true 的版本，release版本的 signingConfig 需要自己配置。 一个 applicationId 唯一确定一个apk 相同的 applicationId，打包的key不同的话，以最先发布的apk的key为准 ProGuard 不同的 build variants 可以采用不同的 ProGuard rules file，当配置了多个时，会把它们合并到一起。 APK Splits 可以使用指定的代码和资源文件来打包对应不同分辨率的apk。（当你的apk为了支持不同分辨率导致体积在100M以上时，才推荐这么做） 源代码设置不同目录下的代码和资源文件会按照是否需要以及相应的优先级合并到一起，组合成最后的 buildVariant 所对应的代码 src/main/ This source set includes code and resources common to all build variants. src/buildType/ only for a specific build type. src/productFlavor/ only for a specific product flavor. src/productFlavorBuildType/ only for a specific build variant. 当不同目录的代码有冲突时，会按照下面的优先级来选择 build variant &gt; build type &gt; product flavor &gt; main source set &gt; library dependencies]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Okhttp header、post参数不支持中文的解决办法]]></title>
      <url>%2F2016%2F10%2F19%2FOkhttp%20header%E3%80%81post%E5%8F%82%E6%95%B0%E4%B8%8D%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
      <content type="text"><![CDATA[现象项目在接入Okhttp请求框架的时候，发现当header或post参数中包含有中文的时候，都会报一个 Unexpected char xx at xx in xx value: xxx 这种格式的错误，下面把原因和解决办法分享给大家 原因查看源码可以发现，不论你从什么入口设置header 或 post参数，Okhttp都会对其进行这样一段代码的检查 private void checkNameAndValue(String name, String value) { if (name == null) throw new NullPointerException(&quot;name == null&quot;); if (name.isEmpty()) throw new IllegalArgumentException(&quot;name is empty&quot;); for (int i = 0, length = name.length(); i &lt; length; i++) { char c = name.charAt(i); if (c &lt;= &apos;\u001f&apos; || c &gt;= &apos;\u007f&apos;) { throw new IllegalArgumentException(Util.format( &quot;Unexpected char %#04x at %d in header name: %s&quot;, (int) c, i, name)); } } if (value == null) throw new NullPointerException(&quot;value == null&quot;); for (int i = 0, length = value.length(); i &lt; length; i++) { char c = value.charAt(i); if (c &lt;= &apos;\u001f&apos; || c &gt;= &apos;\u007f&apos;) { throw new IllegalArgumentException(Util.format( &quot;Unexpected char %#04x at %d in %s value: %s&quot;, (int) c, i, name, value)); } } } 而这也就使得当参数中含有中文时就会报错 解决办法header参数把使用 requestBuilder.header(name , value)的地方 替换成requestBuilder.header(name , getValueEncoded(value) ) 方法代码如下： //由于okhttp header 中的 value 不支持 null, \n 和 中文这样的特殊字符,所以这里 //会首先替换 \n ,然后使用 okhttp 的校验方式,校验不通过的话,就返回 encode 后的字符串 private static String getValueEncoded(String value) { if (value == null) return &quot;null&quot;; String newValue = value.replace(&quot;\n&quot;, &quot;&quot;); for (int i = 0, length = newValue.length(); i &lt; length; i++) { char c = newValue.charAt(i); if (c &lt;= &apos;\u001f&apos; || c &gt;= &apos;\u007f&apos;) { return URLEncoder.encode(newValue, &quot;UTF-8&quot;); } } return newValue; } post参数post参数可以通过将键值对转换为byte数组的形式来避免OKhttp的字符检查 requestBuilder.post(RequestBody.create(MediaType.parse(&quot;application/x-www-form-urlencoded; charset=utf-8&quot;), getRequestData(postParams).toString().getBytes(“UTF-8”))); private static StringBuffer getRequestData(Map&lt;String, String&gt; params) { StringBuffer stringBuffer = new StringBuffer(); try { for (Map.Entry&lt;String, String&gt; entry : params.entrySet()) { stringBuffer.append(entry.getKey()).append(&quot;=&quot;).append(entry.getValue()).append(&quot;&amp;&quot;); } stringBuffer.deleteCharAt(stringBuffer.length() - 1); //删除最后的一个&quot;&amp;&quot; } catch (Exception e) { e.printStackTrace(); } return stringBuffer; } 另外，这里比较重要的还有这句话： MediaType.parse(&quot;application/x-www-form-urlencoded; charset=utf-8&quot; 此处如果没有charset=utf-8的话，服务端获取中文post参数可能会出现乱码]]></content>
    </entry>

    
  
  
</search>
